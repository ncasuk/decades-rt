#!/usr/bin/python
#Class to read CSV protocol descriptions and present them to Python
import os, glob, csv
from twisted.python import log 

class DecadesDataProtocols():
   location = "/opt/decades/dataformats/"
   protocols = {} #Dictionary of protocols
   tables = {} #list of protocol_name to current tablename
   protocol_versions = {} #Dictionary of protocol:version pairs. Version is mtime at present
   field_types_map = {'boolean':'boolean', 'signed_int':'integer', 'single_float':'real', 'double_float':'real','float':'real', 'text':'varchar', 'unsigned_int':'int'} # maps CSV protocol file "types" to PostgreSQL field types (postgreSQL does not have unsigned values)
   new_table_count = 0
   
   def __init__(self):
      dirList=glob.glob(os.path.join(self.location,'*.csv'))
      for proto_path_name in dirList:
         protocol_file_name = os.path.basename(proto_path_name)
         self.protocols[protocol_file_name[0:-4]] = [] #[0:-4] strips the '.csv. off the end
         full_path = os.path.join(self.location,protocol_file_name)
         self.protocol_versions[protocol_file_name[0:-4]] = str(os.stat(full_path)[9]) #we're just after the integer - dots are not allowed in psql tablenames
         protocolReader = csv.DictReader(open(full_path, 'rb'))
         for row in protocolReader:
            self.protocols[protocol_file_name[0:-4]].append(row)

   def available(self):
      return self.protocols.keys()

   def create_table(self, protocol_name, cursor, suffix='_test'):
      #returns a suitable (Postgres)SQL CREATE TABLE command for a named protocol
      tablename = (protocol_name.lower() + suffix)
      s = 'CREATE TABLE %s (' % tablename
      self.tables[protocol_name] = tablename
      for field in self.protocols[protocol_name]:
         #created postgres field spec. Strips leading $ from field name as it won't work
         s = s + " ".join([field['field'].lstrip('$'),self.field_types_map[field['type'].lstrip('<>')],',']) #strips the endianness indicator off, if it is present.

      s = s.rstrip(',') + ")"
      create_index_query = "CREATE INDEX %s_time_index ON %s (utc_time)" % (tablename, tablename)
      #check if table exists (can't use IF NOT EXISTS until postgres 9.1)
      cursor.execute("select exists(select * from information_schema.tables where table_name=%s)", (tablename,))
      if cursor.fetchone()[0]:
         #exists
         log.msg('Table %s exists' % tablename)
         return True
      else:
         #doesn't exist, create table
         log.msg('Creating table %s' % tablename)
         cursor.execute(s)
         self.new_table_count += 1 #increment new table
         log.msg('Creating index %s_time_index' % tablename)
         cursor.execute(create_index_query)
         return cursor.connection.commit()

   def create_view(self, cursor):
      '''creates a SQL table of all the data from the 
      protocol files. Creates a VIEW first as a template'''
      
      squirrel = "CREATE VIEW scratchdata (id, " #id column autogenerated
      select_fields = []
      for proto in self.protocols:
         protoname = self.protocols[proto][0]['field'].lstrip('$')
         fields = []
         for field in self.protocols[proto]: 
            fields.append('"'+protoname.lower()+'_'+field['field'].lstrip('$').lower()+'" ')
            select_fields.append(self.tables[protoname]+'.'+field['field'].lstrip('$').lower())
         squirrel = squirrel + ', '.join(fields) + ','
      table_list = self.tables.items()
      squirrel = squirrel.rstrip(',') + ') AS SELECT row_number() OVER (ORDER BY ' + table_list[0][1] + '.utc_time), ' + ", ".join(select_fields)+' FROM ' #creates an id field based on rownumber of the combined view
      join_clause = table_list[0][1] + ' '
      for table in table_list[1:]: #joins all to the first table
         join_clause = join_clause + " ".join([' LEFT JOIN',table[1],'ON (',table_list[0][1]+'.utc_time=',table[1] + '.utc_time)'])
     
      log.msg(cursor.mogrify(squirrel + join_clause)) 
      cursor.execute('DROP VIEW IF EXISTS scratchdata')
      cursor.execute(squirrel + join_clause)
      cursor.execute('DROP TABLE IF EXISTS mergeddata')
      cursor.execute('CREATE TABLE mergeddata AS SELECT * FROM scratchdata ')
      cursor.execute('ALTER TABLE mergeddata DROP COLUMN id')
      cursor.execute('ALTER TABLE mergeddata ADD COLUMN utc_time INT PRIMARY KEY')
      cursor.execute('ALTER TABLE mergeddata ADD COLUMN id SERIAL UNIQUE')
      cursor.execute('''CREATE OR REPLACE FUNCTION data_merge(sql_update TEXT, sql_insert TEXT) RETURNS VOID AS
$$
DECLARE r INTEGER;
BEGIN
   -- first try to insert and after to update. Note : insert has pk and update not...
  LOOP
    EXECUTE sql_update; 
    GET DIAGNOSTICS r = ROW_COUNT;
    IF r = 1 THEN 
        raise notice '%', r;
        RETURN; 
    END IF;
    BEGIN
      EXECUTE sql_insert;
      RETURN;
      EXCEPTION WHEN unique_violation THEN
         --do nothing and loop
    END;
  END LOOP;
END;
$$
LANGUAGE plpgsql;''')


   def add_data(self, cursor, data, instrument):
      '''adds incoming data to the database. data is a Python 
         dictionary of fieldname=> value pairs'''

      sql_u = []
      sql_i = [[],[]]
      for each in data.iteritems():
         if each[1]=='':
            sql_u.append(cursor.mogrify(instrument+'_'+each[0]+'=%s',(None,))) 
            sql_i[0].append(instrument+'_'+each[0])
            sql_i[1].append(None)
         else:
            sql_u.append(cursor.mogrify(instrument+'_'+each[0]+'=%s',(each[1],))) 
            sql_i[0].append(instrument+'_'+each[0])
            sql_i[1].append(each[1])

      sql_update = ('UPDATE mergeddata SET ' + ", ".join(sql_u) + ' WHERE utc_time=' + cursor.mogrify('%s', (data['utc_time'],)))
      sql_insert = (cursor.mogrify('INSERT INTO mergeddata (' + ", ".join(sql_i[0]) + ', utc_time) VALUES (' + ('%s,' * len(sql_i[1])) + '%s)',sql_i[1] +[data['utc_time']]))
      cursor.execute('SELECT data_merge($$' + sql_update + '$$, $$'+ sql_insert + '$$)')
   

   def fields(self, protocol_name):
      #returns a List of field names
      r = []
      for field in self.protocols[protocol_name]:
         r.append(field['field'].lstrip('$'))

      return r
